// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: query.sql

package ttssqlc

import (
	"context"
	"database/sql"
	"time"
)

const createSession = `-- name: CreateSession :one
INSERT INTO sessions (user_id, token, created_at)
values ($1, $2, $3)
RETURNING id, user_id, token, created_at
`

type CreateSessionParams struct {
	UserID    int64
	Token     string
	CreatedAt time.Time
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.db.QueryRowContext(ctx, createSession, arg.UserID, arg.Token, arg.CreatedAt)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.CreatedAt,
	)
	return i, err
}

const createTask = `-- name: CreateTask :one
INSERT INTO tasks (title, description, result,
created_at, created_by, done_at) values
($1, $2, $3, $4, $5, $6)
RETURNING id, title, description, result, created_at, created_by, done_at
`

type CreateTaskParams struct {
	Title       string
	Description string
	Result      string
	CreatedAt   time.Time
	CreatedBy   int64
	DoneAt      sql.NullTime
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (Task, error) {
	row := q.db.QueryRowContext(ctx, createTask,
		arg.Title,
		arg.Description,
		arg.Result,
		arg.CreatedAt,
		arg.CreatedBy,
		arg.DoneAt,
	)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Result,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.DoneAt,
	)
	return i, err
}

const createTaskDependency = `-- name: CreateTaskDependency :one
INSERT INTO tasks_dependencies 
(task_id, depends_on_id, created_at) values
($1, $2, $3)
RETURNING id, task_id, depends_on_id, created_at
`

type CreateTaskDependencyParams struct {
	TaskID      int64
	DependsOnID int64
	CreatedAt   time.Time
}

func (q *Queries) CreateTaskDependency(ctx context.Context, arg CreateTaskDependencyParams) (TasksDependency, error) {
	row := q.db.QueryRowContext(ctx, createTaskDependency, arg.TaskID, arg.DependsOnID, arg.CreatedAt)
	var i TasksDependency
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.DependsOnID,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (username, password, email, confirmed, created_at)
values ($1, $2, $3, $4, $5)
RETURNING id, username, password, email, confirmed, created_at, root_task_id
`

type CreateUserParams struct {
	Username  string
	Password  sql.NullString
	Email     sql.NullString
	Confirmed sql.NullBool
	CreatedAt time.Time
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.Username,
		arg.Password,
		arg.Email,
		arg.Confirmed,
		arg.CreatedAt,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Email,
		&i.Confirmed,
		&i.CreatedAt,
		&i.RootTaskID,
	)
	return i, err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions
WHERE token = $1
`

func (q *Queries) DeleteSession(ctx context.Context, token string) error {
	_, err := q.db.ExecContext(ctx, deleteSession, token)
	return err
}

const getSession = `-- name: GetSession :one
SELECT users.id AS user_id, users.username, users.email, users.root_task_id FROM
sessions JOIN users ON sessions.user_id = users.id
WHERE token = $1 LIMIT 1
`

type GetSessionRow struct {
	UserID     int64
	Username   string
	Email      sql.NullString
	RootTaskID sql.NullInt64
}

func (q *Queries) GetSession(ctx context.Context, token string) (GetSessionRow, error) {
	row := q.db.QueryRowContext(ctx, getSession, token)
	var i GetSessionRow
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.Email,
		&i.RootTaskID,
	)
	return i, err
}

const getTask = `-- name: GetTask :one
SELECT id, title, description, result, created_at, created_by, done_at FROM tasks
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetTask(ctx context.Context, id int64) (Task, error) {
	row := q.db.QueryRowContext(ctx, getTask, id)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Result,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.DoneAt,
	)
	return i, err
}

const getTaskDependencies = `-- name: GetTaskDependencies :many
SELECT tasks.id, tasks.title, tasks.description, tasks.result, tasks.created_at, tasks.created_by, tasks.done_at FROM tasks_dependencies
JOIN tasks ON tasks_dependencies.depends_on_id = tasks.id
WHERE task_id = $1 LIMIT 100
`

func (q *Queries) GetTaskDependencies(ctx context.Context, taskID int64) ([]Task, error) {
	rows, err := q.db.QueryContext(ctx, getTaskDependencies, taskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Result,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.DoneAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskDependenciesTree = `-- name: GetTaskDependenciesTree :many
WITH RECURSIVE children AS (
    SELECT
        t1.task_id as parent_id,
        t1.depends_on_id as task_id,
        tasks.title,
        tasks.done_at
    FROM
        tasks_dependencies t1
    INNER JOIN tasks ON tasks.id = t1.depends_on_id
    WHERE
        t1.task_id = $1
        AND tasks.done_at IS NULL
    UNION
        SELECT
            t.task_id as parent_id,
            t.depends_on_id as task_id,
            tasks.title,
            tasks.done_at
        FROM
            tasks_dependencies t
        INNER JOIN tasks ON tasks.id = t.depends_on_id
        INNER JOIN children ON children.task_id = t.task_id
        WHERE
            tasks.done_at IS NULL
) SELECT
    parent_id, task_id, title, done_at
FROM
    children
`

type GetTaskDependenciesTreeRow struct {
	ParentID int64
	TaskID   int64
	Title    string
	DoneAt   sql.NullTime
}

func (q *Queries) GetTaskDependenciesTree(ctx context.Context, taskID int64) ([]GetTaskDependenciesTreeRow, error) {
	rows, err := q.db.QueryContext(ctx, getTaskDependenciesTree, taskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTaskDependenciesTreeRow
	for rows.Next() {
		var i GetTaskDependenciesTreeRow
		if err := rows.Scan(
			&i.ParentID,
			&i.TaskID,
			&i.Title,
			&i.DoneAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskParents = `-- name: GetTaskParents :many
SELECT tasks.id, tasks.title, tasks.description, tasks.result, tasks.created_at, tasks.created_by, tasks.done_at FROM tasks_dependencies
JOIN tasks ON tasks_dependencies.task_id = tasks.id
WHERE depends_on_id = $1 LIMIT 100
`

func (q *Queries) GetTaskParents(ctx context.Context, dependsOnID int64) ([]Task, error) {
	rows, err := q.db.QueryContext(ctx, getTaskParents, dependsOnID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Result,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.DoneAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskParentsTree = `-- name: GetTaskParentsTree :many
WITH RECURSIVE parents AS (
    SELECT
        t1.task_id,
        t1.depends_on_id
    FROM
        tasks_dependencies t1
    WHERE
        t1.depends_on_id = $1
    UNION
        SELECT
            t.task_id,
            t.depends_on_id
        FROM
            tasks_dependencies t
        INNER JOIN parents ON parents.task_id = t.depends_on_id
) SELECT
    task_id, depends_on_id
FROM
    parents
`

type GetTaskParentsTreeRow struct {
	TaskID      int64
	DependsOnID int64
}

func (q *Queries) GetTaskParentsTree(ctx context.Context, dependsOnID int64) ([]GetTaskParentsTreeRow, error) {
	rows, err := q.db.QueryContext(ctx, getTaskParentsTree, dependsOnID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTaskParentsTreeRow
	for rows.Next() {
		var i GetTaskParentsTreeRow
		if err := rows.Scan(&i.TaskID, &i.DependsOnID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByName = `-- name: GetUserByName :one
SELECT id, username, password, email, confirmed, created_at, root_task_id FROM users
WHERE username = $1 LIMIT 1
`

func (q *Queries) GetUserByName(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByName, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Email,
		&i.Confirmed,
		&i.CreatedAt,
		&i.RootTaskID,
	)
	return i, err
}

const searchTask = `-- name: SearchTask :many
SELECT id, title, description, result, created_at, created_by, done_at FROM tasks
WHERE
    to_tsvector('english', title) @@ plainto_tsquery($1) AND
    created_by = $2
LIMIT 20
`

type SearchTaskParams struct {
	PlaintoTsquery string
	CreatedBy      int64
}

func (q *Queries) SearchTask(ctx context.Context, arg SearchTaskParams) ([]Task, error) {
	rows, err := q.db.QueryContext(ctx, searchTask, arg.PlaintoTsquery, arg.CreatedBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Result,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.DoneAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setTaskDone = `-- name: SetTaskDone :one
UPDATE tasks
SET done_at = $2
WHERE id = $1
RETURNING id, title, description, result, created_at, created_by, done_at
`

type SetTaskDoneParams struct {
	ID     int64
	DoneAt sql.NullTime
}

func (q *Queries) SetTaskDone(ctx context.Context, arg SetTaskDoneParams) (Task, error) {
	row := q.db.QueryRowContext(ctx, setTaskDone, arg.ID, arg.DoneAt)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Result,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.DoneAt,
	)
	return i, err
}

const unlinkTask = `-- name: UnlinkTask :exec
DELETE FROM tasks_dependencies
WHERE task_id = $1 AND depends_on_id = $2
`

type UnlinkTaskParams struct {
	TaskID      int64
	DependsOnID int64
}

func (q *Queries) UnlinkTask(ctx context.Context, arg UnlinkTaskParams) error {
	_, err := q.db.ExecContext(ctx, unlinkTask, arg.TaskID, arg.DependsOnID)
	return err
}

const updateRootTaskId = `-- name: UpdateRootTaskId :exec
UPDATE users
SET root_task_id = $1
WHERE id = $2
`

type UpdateRootTaskIdParams struct {
	RootTaskID sql.NullInt64
	ID         int64
}

func (q *Queries) UpdateRootTaskId(ctx context.Context, arg UpdateRootTaskIdParams) error {
	_, err := q.db.ExecContext(ctx, updateRootTaskId, arg.RootTaskID, arg.ID)
	return err
}

const updateTaskDescription = `-- name: UpdateTaskDescription :one
UPDATE tasks
SET description = $1
WHERE id = $2
RETURNING id, title, description, result, created_at, created_by, done_at
`

type UpdateTaskDescriptionParams struct {
	Description string
	ID          int64
}

func (q *Queries) UpdateTaskDescription(ctx context.Context, arg UpdateTaskDescriptionParams) (Task, error) {
	row := q.db.QueryRowContext(ctx, updateTaskDescription, arg.Description, arg.ID)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Result,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.DoneAt,
	)
	return i, err
}

const updateTaskTitle = `-- name: UpdateTaskTitle :one
UPDATE tasks
SET title = $1
WHERE id = $2
RETURNING id, title, description, result, created_at, created_by, done_at
`

type UpdateTaskTitleParams struct {
	Title string
	ID    int64
}

func (q *Queries) UpdateTaskTitle(ctx context.Context, arg UpdateTaskTitleParams) (Task, error) {
	row := q.db.QueryRowContext(ctx, updateTaskTitle, arg.Title, arg.ID)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Result,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.DoneAt,
	)
	return i, err
}
